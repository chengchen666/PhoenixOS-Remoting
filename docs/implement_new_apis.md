# Guidelines of implementing new APIs

## Introduction

An API should first be intercepted in `client` side, transfered through `network`, and finally be actually processed in `server` side. As `network` is a generic layer, we only need to focus on `client` and `server` code for implementing new APIs.

## Which API need to be implemented?

Now the implemented APIs are listed in `cudasys/src/hooks/*.rs`. All of the rest are unimplemented yet, but they are still intercepted by auto-generated placeholder functions in `client/src/hijack/*_unimplement.rs`. If we run a application and encounter an unimplemented API, the application will throw an `unimplemented!` error, so we only need to implement those APIs prompted by the error message.

## Steps of implementation

1. Add the API to `cudasys/src/hooks/*.rs`.

There are two ways of implementations: default and custom.

Default implementation is a fallback used when the custom implementation is not provided, and it can handle simple cases. Custom implementation is user-defined or to handle complex cases. If default is enough in your case, add a `#[cuda_hook(...)]` declaration. Otherwise, add a `#[cuda_custom_hook]` declaration. This will prevent system creating unimplemented placeholder and use implemented one instead.

You can read the next section to check if the API can be supported by default implementation.

2. Add implementation code in both client and server side.

For default way,

- hijack and exe functions are automatically generated by build scripts.
- server: add dispatch logic in `server/src/dispatcher/mod.rs`.

For custom way,

- client: add custom hijack function in `client/src/hijack/*_hijack_custom.rs`.
- server: add custom exe function in `server/src/dispatcher/*_exe_custom.rs`, add dispatch logic in `server/src/dispatcher/mod.rs`.

You can refer to existing implementations for examples.

3. Unit test.

Add simple cuda usage test in `tests/cuda_api/` to test the new API.

## Default implementation guide

Default implementation declarations should go to `cudasys/src/hooks/*.rs`. Here's a basic example:

```rust
#[cuda_hook(proc_id = 300)]
fn cuDevicePrimaryCtxGetState(dev: CUdevice, flags: *mut c_uint, active: *mut c_int) -> CUresult;
```

You need to find the function signature in `cudasys/src/bindings/funcs/*.rs` or `client/src/hijack/*_unimplement.rs`. Copy it here and annotate it with `#[cuda_hook(proc_id = ...)]`.

By default, `*mut T` parameters are considered as host output parameters. Use the attributes mentioned below if it's not the case.

### Optimizations

If an API should be implemented with `async_api` optimization, annotate it in the attribute:

```rust
#[cuda_hook(proc_id = 2002, async_api)]
fn cublasSetStream_v2(handle: cublasHandle_t, streamId: cudaStream_t) -> cublasStatus_t;
```

If any of the parameters is output, the code will fail to compile. Possible candidates will be listed in compilation diagnostics.

`shadow_desc` optimizations will be applied automatically.

### Host and device pointers

Annotate a pointer parameter with `#[device]` if it points to device memory. This tells the client to transfer it as-is without dereferencing. The pointer can be either `*const T` or `*mut T`.

Annotate a `*const T` input parameter with `#[host]` if it points to host memory and needs to be dereferenced.

```rust
#[cuda_hook(proc_id = 2005, async_api)]
fn cublasSgemmStridedBatched(
    // ...
    #[host] alpha: *const f32,
    #[device] A: *const f32,
    lda: c_int,
    strideA: c_longlong,
    #[device] B: *const f32,
    ldb: c_int,
    strideB: c_longlong,
    #[host] beta: *const f32,
    #[device] C: *mut f32,
    ldc: c_int,
    strideC: c_longlong,
    batchCount: c_int,
) -> cublasStatus_t;
```

### Host array pointers

Input arrays should be annotated with `#[host(len = ...)]` to specify the length of the array.

```rust
#[cuda_hook(proc_id = 1509, async_api)]
fn cudnnSetTensorNdDescriptor(
    tensorDesc: cudnnTensorDescriptor_t,
    dataType: cudnnDataType_t,
    nbDims: c_int,
    #[host(len = nbDims)] dimA: *const c_int,
    #[host(len = nbDims)] strideA: *const c_int,
) -> cudnnStatus_t;
```

Annotate output arrays in the same way. `*mut T` annotations require `output` or `input` property to make the code clear.

```rust
#[cuda_hook(proc_id = 1533)]
fn cudnnGetConvolutionNdForwardOutputDim(
    convDesc: cudnnConvolutionDescriptor_t,
    inputTensorDesc: cudnnTensorDescriptor_t,
    filterDesc: cudnnFilterDescriptor_t,
    nbDims: c_int,
    #[host(output, len = nbDims)] tensorOuputDimA: *mut c_int,
) -> cudnnStatus_t;
```

Output array attributes accept an optional `cap` property:

```rust
#[cuda_hook(proc_id = 1520)]
fn cudnnGetConvolutionForwardAlgorithm_v7(
    // ...
    requestedAlgoCount: c_int,
    returnedAlgoCount: *mut c_int,
    #[host(output, len = returnedAlgoCount, cap = requestedAlgoCount)]
    perfResults: *mut cudnnConvolutionFwdAlgoPerf_t,
) -> cudnnStatus_t;
```

Using `len = requestedAlgoCount` alone is also correct in this example. However, using `len = returnedAlgoCount` alone will fail to compile since it's an output paramater that's unavailable before the function call returns.

### Hacked types

The build script will check if the hook definition signatures match the bindings. If you really need to reinterpret a pointer parameter, search for `Hacked` for examples. Hacked types will be dereferenced with `std::ptr::read_unaligned()`.

If the features above are not enough, you can add a custom implementation.
